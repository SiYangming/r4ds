# Iteration | 迭代

## Introduction | 简介

In [functions], we talked about how important it is to reduce duplication in your code by creating functions instead of copying-and-pasting. Reducing code duplication has three main benefits:

[functions]讨论了通过创建函数而不是复制粘贴的方式来减少重复代码的重要性。减少重
复代码主要有 3 个好处。

1.  It's easier to see the intent of your code, because your eyes are
    drawn to what's different, not what stays the same.
    
    更容易看清代码的意图，因为吸引我们目光的是那些不同的部分，而不是那些保持不变的部分。
    
1.  It's easier to respond to changes in requirements. As your needs 
    change, you only need to make changes in one place, rather than
    remembering to change every place that you copied-and-pasted the 
    code.
    
    •	更容易对需求变化作出反应。当要修改代码时，只需要在一处进行修改即可，无须对所有复制粘贴的代码都进行修改。
    
1.  You're likely to have fewer bugs because each line of code is 
    used in more places.
    
    •	更容易减少程序 bug，因为每行代码都被多次使用。

One tool for reducing duplication is functions, which reduce duplication by identifying repeated patterns of code and extract them out into independent pieces that can be easily reused and updated. Another tool for reducing duplication is __iteration__, which helps you when you need to do the same thing to multiple inputs: repeating the same operation on different columns, or on different datasets. 
In this chapter you'll learn about two important iteration paradigms: imperative programming and functional programming. On the imperative side you have tools like for loops and while loops, which are a great place to start because they make iteration very explicit, so it's obvious what's happening. However, for loops are quite verbose, and require quite a bit of bookkeeping code that is duplicated for every for loop. Functional programming (FP) offers tools to extract out this duplicated code, so each common for loop pattern gets its own function. Once you master the vocabulary of FP, you can solve many common iteration problems with less code, more ease, and fewer errors.

函数是减少重复代码的一种工具，其减少重复代码的方法是，先识别出代码中的重复模式，然后将其提取出来，成为更容易修改和重用的独立部分。减少重复代码的另一种工具是迭代，它的作用在于可以对多个输入执行同一种处理，比如对多个列或多个数据集进行同样的操作。本章将介绍两种重要的迭代方式：命令式编程和函数式编程。对于命令式编程，我们将介绍 for 循环和 while 循环，它们是很好的学习起点，因为这种迭代过程非常简洁明了。但是，for 循环比较繁琐，而且每个 for 循环中都要重复使用一些记录和跟踪的代码。函数式编程则可以将这些重复代码提取出来，使每个普通的 for 循环都可以通过函数来完成。一旦掌握函数式编程的使用方法，那么你就可以通过更少的代码和更容易的方式解决很多常见的迭代问题，出错的概率也会更小。

### Prerequisites | 准备工作

Once you've mastered the for loops provided by base R, you'll learn some of the powerful programming tools provided by purrr, one of the tidyverse core packages.

如果已经掌握了 R 基础包中的 for 循环，那么你就可以继续学习由 purrr 包提供的一些更加强大的编程工具。purrr 包是 tidyverse 的核心 R 包之一。

```{r setup, message = FALSE}
library(tidyverse)
```

## For loops | for循环

Imagine we have this simple tibble:
假设我们有以下这样一个简单的 tibble：

```{r}
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
```

We want to compute the median of each column. You _could_ do with copy-and-paste:
我们想要计算出每列的中位数。你完全可以使用复制粘贴来完成这个任务：

```{r}
median(df$a)
median(df$b)
median(df$c)
median(df$d)
```

But that breaks our rule of thumb: never copy and paste more than twice. Instead, we could use a for loop:

但这样做就违反了我们的经验法则：永远不要复制粘贴超过 2 次。相反，我们应该使用for 循环：

```{r}
output <- vector("double", ncol(df))  # 1. output 输 出
for (i in seq_along(df)) {            # 2. sequence 序列
  output[[i]] <- median(df[[i]])      # 3. body 循环体
}
output
```

Every for loop has three components:
每个 for 循环都包括 3 个部分。

1.  The __output输出__: `output <- vector("double", length(x))`. 
    Before you start the loop, you must always allocate sufficient space 
    for the output. This is very important for efficiency: if you grow
    the for loop at each iteration using `c()` (for example), your for loop 
    will be very slow. 
    
    在开始循环前，你必须为输出结果分配足够的空间。这对循环效率非常重要，如果在每次迭代中都使用 c() 来保存循环的结果，那么 for 循环的速度就会特别慢。
    
    A general way of creating an empty vector of given length is the `vector()`
    function. It has two arguments: the type of the vector ("logical", 
    "integer", "double", "character", etc) and the length of the vector. 
    
    创建给定长度的空向量的一般方法是使用 vector() 函数，该函数有两个参数：向量类型（"logical"、"integer"、"double"、"character" 等）和向量的长度。

1.  The __sequence序列__: `i in seq_along(df)`. This determines what to loop over:
    each run of the for loop will assign `i` to a different value from 
    `seq_along(df)`. It's useful to think of `i` as a pronoun, like "it".
    
    这部分确定了使用哪些值来进行循环：每一轮 for 循环都会赋予 i 一个来自于 seq_ along(df) 的不同的值。我们可以将 i 看作一个代词，和 it 类似。
    
    You might not have seen `seq_along()` before. It's a safe version of the 
    familiar `1:length(l)`, with an important difference: if you have a
    zero-length vector, `seq_along()` does the right thing:
    
    你可能还不清楚 seq_along() 函数的作用，它与我们熟悉的 1:length(l) 的作用基本相同，但最重要的区别是更加安全。如果我们有一个长度为 0 的向量，那么 seq_along() 会进行正确的处理：

    ```{r}
    y <- vector("double", 0)
    seq_along(y)
    1:length(y)
    ```
    
    You probably won't create a zero-length vector deliberately, but
    it's easy to create them accidentally. If you use `1:length(x)` instead
    of `seq_along(x)`, you're likely to get a confusing error message.
    
    你当然不会故意创建长度为 0 的向量，但很可能会意外生成一个。如果使用 1:length(x) 而不是 seq_along(x)，那么就可能收到一个令人迷惑的错误消息。
    
1.  The __body循环体__: `output[[i]] <- median(df[[i]])`. This is the code that does
    the work. It's run repeatedly, each time with a different value for `i`.
    The first iteration will run `output[[1]] <- median(df[[1]])`, 
    the second will run `output[[2]] <- median(df[[2]])`, and so on.
    
    这部分就是执行具体操作的代码。它们会重复运行，每次运行都使用一个不同的 i 值。第一次迭代运行的是 output[[1]] <- median(df[[1]])，第二次迭代运行的是output[[2]] <- median[[2]]，以此类推。

That's all there is to the for loop! Now is a good time to practice creating some basic (and not so basic) for loops using the exercises below. Then we'll move on some variations of the for loop that help you solve other problems that will crop up in practice. 

关于 for 循环，能讲的就这么多了！现在我们应该使用以下的习题创建一些基础（和不那么基础）的 for 循环来练习一下，然后就可以通过 for 循环的各种变体来解决实际工作中遇到的那些问题了。

### Exercises | 练习

1.  Write for loops to: 
使用 for 循环完成以下操作。

    1. Compute the mean of every column in `mtcars`.  计算出 mtcars 数据集中每列的均值。
    1. Determine the type of each column in `nycflights13::flights`. 确定 nycflights13::flights 数据集中每列的类型。
    1. Compute the number of unique values in each column of `iris`. 计算出 iris 数据集中每列唯一值的数量。
    1. Generate 10 random normals from distributions with means of -10, 0, 10, and 100. 分别使用 μ= -10、0、10 和 100 的正态分布生成 10 个随机数。
    
    Think about the output, sequence, and body __before__ you start writing
    the loop.
    
    在编写代码前，仔细思考各个 for 循环的输出、序列和循环体。

1.  Eliminate the for loop in each of the following examples by taking 
    advantage of an existing function that works with vectors:
    
    使用支持向量运算的现有函数替换以下示例中的 for 循环。
    
    ```{r, eval = FALSE}
    out <- ""
    for (x in letters) {
      out <- stringr::str_c(out, x)
    }
    
    x <- sample(100)
    sd <- 0
    for (i in seq_along(x)) {
      sd <- sd + (x[i] - mean(x)) ^ 2
    }
    sd <- sqrt(sd / (length(x) - 1))
    
    x <- runif(100)
    out <- vector("numeric", length(x))
    out[1] <- x[1]
    for (i in 2:length(x)) {
      out[i] <- out[i - 1] + x[i]
    }
    ```

1.  Combine your function writing and for loop skills:
使用函数和 for 循环完成以下任务。

    1. Write a for loop that `prints()` the lyrics to the children's song 
       "Alice the camel".
       
       使用 for 循环和 prints() 打印出儿歌“Alice the Camel”的歌词。

    1. Convert the nursery rhyme "ten in the bed" to a function. Generalise 
       it to any number of people in any sleeping structure.
       
       将儿歌“Ten in the Bed”转换成一个函数，将其扩展为任意数量的小朋友和任意种类的寝具。

    1. Convert the song "99 bottles of beer on the wall" to a function.
       Generalise to any number of any vessel containing any liquid on 
       any surface.
       
       将歌曲“99 Bottles of Beer on the Wall”转换成一个函数，将其扩展为任意数量、任意容器、任意液体和任意表面。

1.  It's common to see for loops that don't preallocate the output and instead
    increase the length of a vector at each step:
    
    我们经常见到并不预先分配好输出空间，而是在每次循环中增加向量长度的 for 循环， 比如：
    
    ```{r, eval = FALSE}
    output <- vector("integer", 0)
    for (i in seq_along(x)) {
      output <- c(output, lengths(x[[i]]))
    }
    output
    ```
    
    How does this affect performance? Design and execute an experiment.
    
    这种方式是如何影响性能的？设计一个实验说明一下。

## For loop variations | for循环的变体

Once you have the basic for loop under your belt, there are some variations that you should be aware of. These variations are important regardless of how you do iteration, so don't forget about them once you've mastered the FP techniques you'll learn about in the next section.

如果已经掌握了基础的 for 循环，那么你就应该再熟悉一下它的几种变体。不管进行何种迭代，这些变体都非常重要。因此，即使在下一节中掌握了函数式编程技术，也不要忘了如何使用这些变体。

There are four variations on the basic theme of the for loop:

在基础 for 循环之上有 4 种变体。

1.  Modifying an existing object, instead of creating a new object. 修改现有对象，而不是创建新对象。
1.  Looping over names or values, instead of indices. 使用名称或值进行迭代，而不是使用索引。
1.  Handling outputs of unknown length. 处理未知长度的输出。
1.  Handling sequences of unknown length. 处理未知长度的序列。

### Modifying an existing object | 修改现有对象

Sometimes you want to use a for loop to modify an existing object. For example, remember our challenge from [functions]. We wanted to rescale every column in a data frame:

有时我们会希望使用 for 循环来修改现有的对象。例如，回想一下第 14 章中的一个问题， 我们希望对数据框中的每列进行调整：

```{r}
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}

df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)
```

To solve this with a for loop we again think about the three components:
为了使用 for 循环解决这个问题，我们还是先思考一下 for 循环的 3 个部分。

1.  __Output输出__: we already have the output --- it's the same as the input! 我们已经有了输出，和输入是相同的！


1.  __Sequence序列__: we can think about a data frame as a list of columns, so 
    we can iterate over each column with `seq_along(df)`. 我们可以将数据框看作数据列的列表，因此可以使用 seq_along(df) 在每列中进行迭代。

1.  __Body函数体__: apply `rescale01()`.
可以使用 rescale01() 函数。

This gives us: 因此可以写出以下代码：

```{r}
for (i in seq_along(df)) {
  df[[i]] <- rescale01(df[[i]])
}
```

Typically you'll be modifying a list or data frame with this sort of loop, so remember to use `[[`, not `[`. You might have spotted that I used `[[` in all my for loops: I think it's better to use `[[` even for atomic vectors because it makes it clear that I want to work with a single element.

一般来说，你可以使用类似的循环来修改列表或数据框，要记住使用 [[，而不是 [。你或许已经发现了，我们在所有 for 循环中使用的都是 [[。我们认为甚至在原子向量中最好也使用 [[，因为它可以明确表示我们要处理的是单个元素。

### Looping patterns | 循环模式

There are three basic ways to loop over a vector. So far I've shown you the most general: looping over the numeric indices with `for (i in seq_along(xs))`, and extracting the value with `x[[i]]`. There are two other forms:

对向量进行循环的基本方式有 3 种，至此我们只介绍了最常用的一种方式：通过 for (i in seq_along(xs)) 使用数值索引进行循环，并使用 x[[i]] 提取出相应的值。另外两种循环方式如下。

1.  Loop over the elements: `for (x in xs)`. This is most useful if you only
    care about side-effects, like plotting or saving a file, because it's
    difficult to save the output efficiently.
    
    •	使用元素进行循环：for (x in xs)。如果只关心副作用，比如绘图或保存文件，那么这种方式是最适合的，因为有效率地保存输出结果是非常困难的。

1.  Loop over the names: `for (nm in names(xs))`. This gives you name, which
    you can use to access the value with `x[[nm]]`. This is useful if you want 
    to use the name in a plot title or a file name. If you're creating
    named output, make sure to name the results vector like so:
    
    •	使用名称进行循环：for (nm in names(xs))。这种方式会给出一个名称，你可以使用这个名称和 x[[nm]] 来访问元素的值。如果想要在图表标题或文件名中使用元素名称，那么你就应该使用这种方式。
    如果想要创建命名的输出向量，请一定按照如下方式进行命名：
    
    ```{r, eval = FALSE}
    results <- vector("list", length(x))
    names(results) <- names(x)
    ```

Iteration over the numeric indices is the most general form, because given the position you can extract both the name and the value:

使用数值索引进行循环是最常用的方式，因为给定位置后，就可以提取出元素的名称和值：

```{r, eval = FALSE}
for (i in seq_along(x)) {
  name <- names(x)[[i]]
  value <- x[[i]]
}
```

### Unknown output length | 未知的输出长度

Sometimes you might not know how long the output will be. For example, imagine you want to simulate some random vectors of random lengths. You might be tempted to solve this problem by progressively growing the vector:

有时你可能不知道输出的长度。例如，假设你想模拟长度随机的一些随机向量。你或许想要通过逐渐增加向量长度的方式来解决这个问题：

```{r}
means <- c(0, 1, 2)

output <- double()
for (i in seq_along(means)) {
  n <- sample(100, 1)
  output <- c(output, rnorm(n, means[[i]]))
}
str(output)
```

But this is not very efficient because in each iteration, R has to copy all the data from the previous iterations. In technical terms you get "quadratic" ($O(n^2)$) behaviour which means that a loop with three times as many elements would take nine ($3^2$) times as long to run.

但这并不是一种非常高效的方式，因为 R 要在每次迭代中复制上一次迭代中的所有数据。从技术角度来看，你执行了一种“平方”（O(n2)）操作，这意味着，如果元素数量增加到原来的 3 倍，那么循环时间就要增加到原来的 9 倍。

A better solution to save the results in a list, and then combine into a single vector after the loop is done:

更好的解决方式是将结果保存在一个列表中，循环结束后再组合成一个向量：

```{r}
out <- vector("list", length(means))
for (i in seq_along(means)) {
  n <- sample(100, 1)
  out[[i]] <- rnorm(n, means[[i]])
}
str(out)
str(unlist(out))
```

Here I've used `unlist()` to flatten a list of vectors into a single vector. A stricter option is to use `purrr::flatten_dbl()` --- it will throw an error if the input isn't a list of doubles.

这里我们使用了 unlist() 函数将一个向量列表转换为单个向量。更严格的一种转换方式是使用 purrr::flatten_dbl() 函数，如果输入不是双精度型列表，那么它就会抛出一个错误。

This pattern occurs in other places too:
其他情况下也可以使用这种编码模式。

1.  You might be generating a long string. Instead of `paste()`ing together 
    each iteration with the previous, save the output in a character vector and
    then combine that vector into a single string with 
    `paste(output, collapse = "")`.
    
    •	你或许会生成一个很长的字符串。不要使用 paste() 函数将每次迭代的结果与上一次连接起来，而应该将每次迭代结果保存在字符向量中，然后再使用 paste(output, collapse = "") 将这个字符向量组合成一个字符串。
   
1.  You might be generating a big data frame. Instead of sequentially
    `rbind()`ing in each iteration, save the output in a list, then use 
    `dplyr::bind_rows(output)` to combine the output into a single
    data frame.
    
    •	你或许会生成一个很大的数据框。不要在每次迭代中依次使用 rbind() 函数，而应该将每次迭代结果保存在列表中，再使用 dplyr::bind_rows(output) 将结果组合成数据框。

Watch out for this pattern. Whenever you see it, switch to a more complex result object, and then combine in one step at the end.

注意这种模式。只要遇到类似情况，就应该使用一个更复杂的对象来保存每次迭代的结果，最后再一次性组合起来。

### Unknown sequence length | 未知的序列长度

Sometimes you don't even know how long the input sequence should run for. This is common when doing simulations. For example, you might want to loop until you get three heads in a row. You can't do that sort of iteration with the for loop. Instead, you can use a while loop. A while loop is simpler than for loop because it only has two components, a condition and a body:

有时你甚至不知道输入序列的长度。这种情况在模拟时很常见。例如，在掷硬币时，你想要循环到连续 3 次掷出正面向上。这种迭代不能使用 for 循环来实现，而应该使用 while 循环。while 循环比 for 循环更简单，因为前者只需要 2 个部分：条件和循环体。

```{r, eval = FALSE}
while (condition) {
  # body
  # 循环体
}
```

A while loop is also more general than a for loop, because you can rewrite any for loop as a while loop, but you can't rewrite every while loop as a for loop:

while 循环也比 for 循环更常用，因为任何 for 循环都可以使用 while 循环重新实现，但不是所有 while 循环都能使用 for 循环重新实现：

```{r, eval = FALSE}
for (i in seq_along(x)) {
  # body
  # 循环体
}

# Equivalent to
# 等价于
i <- 1
while (i <= length(x)) {
  # body
  # 循环体
  i <- i + 1 
}
```

Here's how we could use a while loop to find how many tries it takes to get three heads in a row:

在以下示例中，我们使用 while 循环找出了连续 3 次掷出正面向上的硬币所需的投掷次数：

```{r}
flip <- function() sample(c("T", "H"), 1)

flips <- 0
nheads <- 0

while (nheads < 3) {
  if (flip() == "H") {
    nheads <- nheads + 1
  } else {
    nheads <- 0
  }
  flips <- flips + 1
}
flips
```

I mention while loops only briefly, because I hardly ever use them. They're most often used for simulation, which is outside the scope of this book. However, it is good to know they exist so that you're prepared for problems where the number of iterations is not known in advance.

我们只简单介绍了一下 while 循环，因为几乎用不到。while 循环最常用于模拟，可本书中并不包括这项内容。但是，知道它的存在还是很重要的，当遇到事先不知道迭代次数的问题时，你就可以使用 while 循环来解决。

### Exercises | 练习

1.  Imagine you have a directory full of CSV files that you want to read in.
    You have their paths in a vector, 
    `files <- dir("data/", pattern = "\\.csv$", full.names = TRUE)`, and now
    want to read each one with `read_csv()`. Write the for loop that will 
    load them into a single data frame. 
    
    假设一个目录中全是你想要读入的 CSV 文件。你已经将这些文件的路径保存在向量files <- dir("data/", pattern = "\\.csv$", full.names = TRUE) 中，现在想要使用read_csv() 函数来读取每个文件。编写一个 for 循环将这些文件加载到一个数据框中。

1.  What happens if you use `for (nm in names(x))` and `x` has no names?
    What if only some of the elements are named? What if the names are
    not unique?
    
    如果使用了 for (nm in names(x))，但 x 中并没有名称，那么会发生什么情况？如果 x 中只有部分元素有名称，那么会发生什么情况？如果名称不是唯一的，又会发生什么情况？

1.  Write a function that prints the mean of each numeric column in a data 
    frame, along with its name. For example, `show_mean(iris)` would print:
    
    编写一个函数，使其输出一个数据框中所有数值列的均值及名称。例如，show_mean(iris) 会输出以下结果。
    
    ```{r, eval = FALSE}
    show_mean(iris)
    #> Sepal.Length: 5.84
    #> Sepal.Width:  3.06
    #> Petal.Length: 3.76
    #> Petal.Width:  1.20
    ```
    
    (Extra challenge: what function did I use to make sure that the numbers
    lined up nicely, even though the variable names had different lengths?)
    
    （附加题：虽然变量名称的长度不同，但我们使用了哪个函数确保数值可以整齐排列？）

1.  What does this code do? How does it work? 以下代码的作用是什么？它是如何运行的？

    ```{r, eval = FALSE}
    trans <- list( 
      disp = function(x) x * 0.0163871,
      am = function(x) {
        factor(x, labels = c("auto", "manual"))
      }
    )
    for (var in names(trans)) {
      mtcars[[var]] <- trans[[var]](mtcars[[var]])
    }
    ```

## For loops vs. functionals | for循环与函数式编程

For loops are not as important in R as they are in other languages because R is a functional programming language. This means that it's possible to wrap up for loops in a function, and call that function instead of using the for loop directly.

for 循环在 R 中不像在其他语言中那么重要，因为 R 是一门函数式编程语言。这意味着可以先将 for 循环包装在函数中，然后再调用这个函数，而不是直接使用 for 循环。

To see why this is important, consider (again) this simple data frame:

为了说明函数式编程的重要性，（再次）思考一下这个简单的数据框：

```{r}
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
```

Imagine you want to compute the mean of every column. You could do that with a for loop:
假设想要计算每列的均值。你可以使用 for 循环来完成这个任务：

```{r}
output <- vector("double", length(df))
for (i in seq_along(df)) {
  output[[i]] <- mean(df[[i]])
}
output
```

You realise that you're going to want to compute the means of every column pretty frequently, so you extract it out into a function:
然后你意识到会非常频繁地计算每列均值，因此将这段代码提取出来，转换成一个函数：

```{r}
col_mean <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- mean(df[[i]])
  }
  output
}
```

But then you think it'd also be helpful to be able to compute the median, and the standard deviation, so you copy and paste your `col_mean()` function and replace the `mean()` with `median()` and `sd()`:

接着你又觉得应该计算出每列的中位数和标准差，因此复制粘贴了函数 col_mean()，并使用 median() 和 sd() 函数替换了 mean() 函数：

```{r}
col_median <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- median(df[[i]])
  }
  output
}
col_sd <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- sd(df[[i]])
  }
  output
}
```

Uh oh! You've copied-and-pasted this code twice, so it's time to think about how to generalise it. Notice that most of this code is for-loop boilerplate and it's hard to see the one thing (`mean()`, `median()`, `sd()`) that is different between the functions.

啊哦！你又复制粘贴了 2 次，因此应该思考一下如何扩展这段代码。注意，这段代码中大部分是一个 for 循环模板，而且很难看出不同函数（mean()、median() 和 sd()）之间的区别。

What would you do if you saw a set of functions like this:
如果看见以下函数，你应该如何做？

```{r}
f1 <- function(x) abs(x - mean(x)) ^ 1
f2 <- function(x) abs(x - mean(x)) ^ 2
f3 <- function(x) abs(x - mean(x)) ^ 3
```

Hopefully, you'd notice that there's a lot of duplication, and extract it out into an additional argument:
希望你能够发现这段代码中有很多重复，并可以使用一个附加参数来提取重复代码：

```{r}
f <- function(x, i) abs(x - mean(x)) ^ i
```

You've reduced the chance of bugs (because you now have 1/3 of the original code), and made it easy to generalise to new situations. 
你已经减少了出错的概率（因为现在的代码只是原来的 1/3），而且这个函数更容易推广到新场景。

We can do exactly the same thing with `col_mean()`, `col_median()` and `col_sd()` by adding an argument that supplies the function to apply to each column:
通过添加支持函数应用到每列的一个参数，我们可以使用同一个函数完成与 col_mean()、col_median() 和 col_sd() 函数相同的操作：

```{r}
col_summary <- function(df, fun) {
  out <- vector("double", length(df))
  for (i in seq_along(df)) {
    out[i] <- fun(df[[i]])
  }
  out
}
col_summary(df, median)
col_summary(df, mean)
```

The idea of passing a function to another function is an extremely powerful idea, and it's one of the behaviours that makes R a functional programming language. It might take you a while to wrap your head around the idea, but it's worth the investment. In the rest of the chapter, you'll learn about and use the __purrr__ package, which provides functions that eliminate the need for many common for loops. The apply family of functions in base R (`apply()`, `lapply()`, `tapply()`, etc) solve a similar problem, but purrr is more consistent and thus is easier to learn.

将函数作为参数传入另一个函数的这种做法是一种非常强大的功能，它是促使 R 成为函数式编程语言的因素之一。你需要花些时间才能真正理解这种思想，但这绝对是值得的。在本章剩余部分，我们将学习和使用 purrr 包，它提供的函数可以替代很多常见的 for 循环应用。R 基础包中的应用函数族（apply()、lapply()、tapply() 等）也可以完成类似的任务，但 purrr 包中的函数更一致，也更易于学习。

The goal of using purrr functions instead of for loops is to allow you to break common list manipulation challenges into independent pieces: 

使用 purrr 函数代替 for 循环的目的是将常见的列表处理问题分解为独立的几个部分。

1. How can you solve the problem for a single element of the list? Once
   you've solved that problem, purrr takes care of generalising your
   solution to every element in the list.
   
   •	对于列表中的单个元素，你能找到解决问题的方法吗？如果找到了解决方法，那么你就可以使用 purrr 将这种方法扩展到列表中的所有元素。

1. If you're solving a complex problem, how can you break it down into
   bite-sized pieces that allow you to advance one small step towards a 
   solution? With purrr, you get lots of small pieces that you can
   compose together with the pipe.
   
   •	如果你面临的是一个非常复杂的问题，那么如何将其分解为几个可行的子问题，然后循序渐进地解决，直至完成最终的解决方案？使用 purrr，你可以解决很多子问题，然后再通过管道操作将这些问题的结果组合起来。

This structure makes it easier to solve new problems. It also makes it easier to understand your solutions to old problems when you re-read your old code.

这种方法可以让你更轻松地解决新问题，对于老问题，你也可以在重温代码时更轻松地理解当时的解决方案。

### Exercises | 练习

1.  Read the documentation for `apply()`. In the 2d case, what two for loops
    does it generalise?
    
    阅读 apply() 函数的文档。在第二种情形中，它会扩展出哪两种 for 循环？

1.  Adapt `col_summary()` so that it only applies to numeric columns
    You might want to start with an `is_numeric()` function that returns
    a logical vector that has a TRUE corresponding to each numeric column.
    
    修改 col_summary() 函数，让其只应用于数值型的列。你可以使用 is_numeric() 函数返回一个逻辑向量，其中的 TRUE 值就对应每个数值型列。

## The map functions | 映射函数

The pattern of looping over a vector, doing something to each element and saving the results is so common that the purrr package provides a family of functions to do it for you. There is one function for each type of output:

先对向量进行循环、然后对其每个元素进行一番处理，最后保存结果。这种模式太普遍了，因此 purrr 包提供了一个函数族来替你完成这种操作。每种类型的输出都有一个相应的函数：

* `map()`     makes a list. 用于输出列表；
* `map_lgl()` makes a logical vector. 用于输出逻辑型向量；
* `map_int()` makes an integer vector. 用于输出整型向量；
* `map_dbl()` makes a double vector. 用于输出双精度型向量；
* `map_chr()` makes a character vector. 用于输出字符型向量。

Each function takes a vector as input, applies a function to each piece, and then returns a new vector that's the same length (and has the same names) as the input. The type of the vector is determined by the suffix to the map function. 

每个函数都使用一个向量作为输入，并对向量的每个元素应用一个函数，然后返回和输入向量同样长度（同样名称）的一个新向量。向量的类型由映射函数的后缀决定。

Once you master these functions, you'll find it takes much less time to solve iteration problems. But you should never feel bad about using a for loop instead of a map function. The map functions are a step up a tower of abstraction, and it can take a long time to get your head around how they work. The important thing is that you solve the problem that you're working on, not write the most concise and elegant code (although that's definitely something you want to strive towards!).

一旦掌握了这些函数，你就会发现可以在解决迭代问题时节省大量时间。但你无须因为使用了 for 循环，没有使用映射函数而感到内疚。映射函数是一种高度抽象，需要花费很长时间才能理解其工作原理。重要的事情是解决工作中遇到的问题，而不是写出最简洁优雅的代码（尽管肯定也应该为之努力！）

Some people will tell you to avoid for loops because they are slow. They're wrong! (Well at least they're rather out of date, as for loops haven't been slow for many years.) The chief benefits of using functions like `map()` is not speed, but clarity: they make your code easier to write and to read.

可能有些人会告诉你不要使用 for 循环，因为它们很慢。这些人完全错了！（至少他们已经赶不上时代了，因为 for 循环已经有很多年都不慢了。）使用 map() 函数的主要优势不是速度，而是简洁：它们可以让你的代码更易编写，也更易读。

We can use these functions to perform the same computations as the last for loop. Those summary functions returned doubles, so we need to use `map_dbl()`:

我们可以使用这些函数来执行与最后一个 for 循环相同的操作。因为那些摘要函数返回的是双精度数，所以我们需要使用 map_dbl() 函数：

```{r}
map_dbl(df, mean)
map_dbl(df, median)
map_dbl(df, sd)
```

Compared to using a for loop, focus is on the operation being performed (i.e. `mean()`, `median()`, `sd()`), not the bookkeeping required to loop over every element and store the output. This is even more apparent if we use the pipe:

与 for 循环相比，映射函数的重点在于需要执行的操作（即 mean()、median() 和 sd()），而不是在所有元素中循环所需的跟踪记录以及保存结果。如果使用管道，这一点就会表现得更加明显：

```{r}
df %>% map_dbl(mean)
df %>% map_dbl(median)
df %>% map_dbl(sd)
```

There are a few differences between `map_*()` and `col_summary()`:

map_*() 和 col_summary() 具有以下几点区别。

*   All purrr functions are implemented in C. This makes them a little faster
    at the expense of readability.
    
    •	所有 purrr 函数都是用 C 实现的。这使得它们的速度非常快，但牺牲了一些可读性。
    
*   The second argument, `.f`, the function to apply, can be a formula, a 
    character vector, or an integer vector. You'll learn about those handy 
    shortcuts in the next section.
    
    •	第二个参数（即 .f，要应用的函数）可以是一个公式、一个字符向量或一个整型向量。下一节将介绍这些快捷方式。
    
*   `map_*()` uses ... ([dot dot dot]) to pass along additional arguments 
    to `.f` each time it's called:
    
    •	map_*() 使用 ...（参见 14.5.3 节）向 .f 传递一些附加参数，供其在每次调用时使用：

    ```{r}
    map_dbl(df, mean, trim = 0.5)
    ```

*   The map functions also preserve names:
•	映射函数还可以保留名称：

    ```{r}
    z <- list(x = 1:3, y = 4:5)
    map_int(z, length)
    ```

### Shortcuts | 快捷方式

There are a few shortcuts that you can use with `.f` in order to save a little typing. Imagine you want to fit a linear model to each group in a dataset. The following toy example splits up the `mtcars` dataset into three pieces (one for each value of cylinder) and fits the same linear model to each piece: 

对于参数 .f，你可以使用几种快捷方式来减少输入量。假设你想对某个数据集中的每个分组都拟合一个线性模型。以下这个简单示例将 mtcars 数据集拆分成 3 个部分（按照气缸的值分类），并对每个部分拟合一个线性模型：

```{r}
models <- mtcars %>% 
  split(.$cyl) %>% 
  map(function(df) lm(mpg ~ wt, data = df))
```

The syntax for creating an anonymous function in R is quite verbose so purrr provides a convenient shortcut: a one-sided formula.

因为 R 中创建匿名函数的语法比较繁琐，所以 purrr 提供了一种更方便的快捷方式——单侧公式：

```{r}
models <- mtcars %>% 
  split(.$cyl) %>% 
  map(~lm(mpg ~ wt, data = .))
```

Here I've used `.` as a pronoun: it refers to the current list element (in the same way that `i` referred to the current index in the for loop). 

我们在以上示例中使用了 . 作为一个代词：它表示当前列表元素（与 for 循环中用 i 表示当前索引是一样的）。

When you're looking at many models, you might want to extract a summary statistic like the $R^2$. To do that we need to first run `summary()` and then extract the component called `r.squared`. We could do that using the shorthand for anonymous functions:

当检查多个模型时，有时你会需要提取出像 R2 这样的摘要统计量。要想完成这个任务，需要先运行 summary() 函数，然后提取出结果中的 r.squared。我们可以使用匿名函数的快捷方式来完成这个操作：

```{r}
models %>% 
  map(summary) %>% 
  map_dbl(~.$r.squared)
```

But extracting named components is a common operation, so purrr provides an even shorter shortcut: you can use a string.

因为提取命名成分的这种操作非常普遍，所以 purrr 提供了一种更为简洁的快捷方式：使用字符串。

```{r}
models %>% 
  map(summary) %>% 
  map_dbl("r.squared")
```

You can also use an integer to select elements by position: 

你还可以使用整数按照位置来选取元素：

```{r}
x <- list(list(1, 2, 3), list(4, 5, 6), list(7, 8, 9))
x %>% map_dbl(2)
```

### Base R | R基础包
  
If you're familiar with the apply family of functions in base R, you might have noticed some similarities with the purrr functions:

如果非常熟悉 R 基础包中的应用函数族，那么你会发现它们与 purrr 函数具有以下共同点。

*   `lapply()` is basically identical to `map()`, except that `map()` is 
    consistent with all the other functions in purrr, and you can use the 
    shortcuts for `.f`.
    
    •	lapply() 函数与 map 函数的功能基本相同，差别在于 map() 函数与 purrr 包中的其他函数是一致的，而且可以对 .f 使用快捷方式。

*   Base `sapply()` is a wrapper around `lapply()` that automatically
    simplifies the output. This is useful for interactive work but is 
    problematic in a function because you never know what sort of output
    you'll get:
    
    •	R 基础包中的 sapply() 函数是对 lapply() 的包装，可以自动简化输出。这对交互工作是有用的，但作为函数则是有问题的，因为你不知道会得到什么样的输出：
    
    ```{r}
    x1 <- list(
      c(0.27, 0.37, 0.57, 0.91, 0.20),
      c(0.90, 0.94, 0.66, 0.63, 0.06), 
      c(0.21, 0.18, 0.69, 0.38, 0.77)
    )
    x2 <- list(
      c(0.50, 0.72, 0.99, 0.38, 0.78), 
      c(0.93, 0.21, 0.65, 0.13, 0.27), 
      c(0.39, 0.01, 0.38, 0.87, 0.34)
    )
    
    threshold <- function(x, cutoff = 0.8) x[x > cutoff]
    x1 %>% sapply(threshold) %>% str()
    x2 %>% sapply(threshold) %>% str()
    ```

*   `vapply()` is a safe alternative to `sapply()` because you supply an
    additional argument that defines the type. The only problem with 
    `vapply()` is that it's a lot of typing: 
    `vapply(df, is.numeric, logical(1))` is equivalent to
    `map_lgl(df, is.numeric)`. One advantage of `vapply()` over purrr's map
    functions is that it can also produce matrices --- the map functions only 
    ever produce vectors.
    
    •	vapply() 函数是sapply() 的一种安全替代方式，因为前者可以提供额外的参数来定义类型。vapply() 的唯一缺点是输入量较大：vapply(df, is.numeric, logical(1)) 等价于 map_ lgl(df, is.numeric)。vapply() 胜于 purrr 中的映射函数的一点是，它可以生成矩阵，而映射函数只能生成向量。

I focus on purrr functions here because they have more consistent names and arguments, helpful shortcuts, and in the future will provide easy parallelism and progress bars.

本章重点介绍 purrr 函数，因为它们具有更加一致的名称和参数，还有好用的快捷方式， 而且未来还可以轻松实现并行计算，以及方便美观的进度条。

### Exercises | 练习

1.  Write code that uses one of the map functions to: 
编写代码以使用一种映射函数完成以下任务。

    1. Compute the mean of every column in `mtcars`. 计算 mtcars 数据集中每列的均值。
    1. Determine the type of each column in `nycflights13::flights`. 确定 nycflights13::flights 数据集中每列的类型。
    1. Compute the number of unique values in each column of `iris`. 计算 iris 数据集中每列唯一值的数量。
    1. Generate 10 random normals from distributions with means of -10, 0, 10, and 100. 分别使用 μ= 10、0、10 和 100 的正态分布生成 10 个随机数。

1.  How can you create a single vector that for each column in a data frame
    indicates whether or not it's a factor?
    
    如何建立一个向量来表明数据框中的每一列是否为一个因子？

1.  What happens when you use the map functions on vectors that aren't lists?
    What does `map(1:5, runif)` do? Why?
    
    如果在非列表向量上使用映射函数，那么会发生什么情况？ map(1:5, runif) 的作用是什么？为什么？
    
1.  What does `map(-2:2, rnorm, n = 5)` do? Why?
    What does `map_dbl(-2:2, rnorm, n = 5)` do? Why?
    
    map(-2:2, rnorm, n = 5) 的作用是什么？为什么？ map_dbl(-2:2, rnorm, n = 5) 的作用又是什么？为什么？

1.  Rewrite `map(x, function(df) lm(mpg ~ wt, data = df))` to eliminate the 
    anonymous function. 
    
    重写 map(x, function(df) lm(mpg ~ wt, data = df)) 这段代码，去除匿名函数。

## Dealing with failure | 对操作失败的处理

When you use the map functions to repeat many operations, the chances are much higher that one of those operations will fail. When this happens, you'll get an error message, and no output. This is annoying: why does one failure prevent you from accessing all the other successes? How do you ensure that one bad apple doesn't ruin the whole barrel?

当使用映射函数重复多种操作时，某次操作失败的概率会大大增加。当这种情况发生时， 你不仅会收到一条错误消息，而且不会得到任何结果。这很令人恼火：为什么一次失败会使得我们无法得到所有其他成功操作的结果？怎样才能保证不会出现一条鱼腥了一锅汤的情况？

In this section you'll learn how to deal with this situation with a new function: `safely()`. `safely()` is an adverb: it takes a function (a verb) and returns a modified version. In this case, the modified function will never throw an error. Instead, it always returns a list with two elements:

本节将介绍如何使用函数 safely() 来处理这种情况。safely() 是一个修饰函数（副词），它接受一个函数（动词），对其进行修改并返回修改后的函数。这样一来，修改后的函数就不会抛出错误。相反，它总是会返回由以下两个元素组成的一个列表。

1. `result` is the original result. If there was an error, this will be `NULL`.

原始结果。如果出现错误，那么它就是 NULL。

1. `error` is an error object. If the operation was successful, this will be 
   `NULL`.
   
   错误对象。如果操作成功，那么它就是 NULL。

(You might be familiar with the `try()` function in base R. It's similar, but because it sometimes returns the original result and it sometimes returns an error object it's more difficult to work with.)

（你可能非常熟悉 R 基础包中的 try() 函数，safely() 函数确实和它很相似。但因为 safely()有时会返回原始结果，有时会返回错误对象，所以处理起来更困难一些。） ：

Let's illustrate this with a simple example: `log()`:

我们使用一个简单的 log() 函数来进行说明

```{r}
safe_log <- safely(log)
str(safe_log(10))
str(safe_log("a"))
```

When the function succeeds, the `result` element contains the result and the `error` element is `NULL`. When the function fails, the `result` element is `NULL` and the `error` element contains an error object.

当函数成功运行时，result 元素中包含原始结果，error 元素的值是 NULL；当函数运行失败时，result 元素的值是 NULL，error 元素中包含错误对象。

`safely()` is designed to work with map:

safely() 也可以与 map() 函数共同使用：

```{r}
x <- list(1, 10, "a")
y <- x %>% map(safely(log))
str(y)
```

This would be easier to work with if we had two lists: one of all the errors and one of all the output. That's easy to get with `purrr::transpose()`:

如果将以上结果转换为两个列表，一个列表包含所有错误对象，另一个列表包含所有原始结果，那么处理起来就会更加容易。可以使用 purrr::transpose() 函数轻松完成这个任务：

```{r}
y <- y %>% transpose()
str(y)
```

It's up to you how to deal with the errors, but typically you'll either look at the values of `x` where `y` is an error, or work with the values of `y` that are ok:

你可以自行决定如何处理错误对象，但一般来说，你应该检查一下 y 中错误对象所对应的 x 值，或者使用 y 中的正常结果进行一些处理：

```{r}
is_ok <- y$error %>% map_lgl(is_null)
x[!is_ok]
y$result[is_ok] %>% flatten_dbl()
```

Purrr provides two other useful adverbs:
purrr 还提供了另外两个有用的修饰函数。

*   Like `safely()`, `possibly()` always succeeds. It's simpler than `safely()`, 
    because you give it a default value to return when there is an error. 
    
    •	与 safely() 类似，possibly() 函数也总是会成功返回。它比 safely() 还要简单一些， 因为可以设定出现错误时返回一个默认值：
    
    ```{r}
    x <- list(1, 10, "a")
    x %>% map_dbl(possibly(log, NA_real_))
    ```
    
*   `quietly()` performs a similar role to `safely()`, but instead of capturing
    errors, it captures printed output, messages, and warnings:
    
    •	quietly() 函数与 safely() 的作用基本相同，但前者的结果中不包含错误对象，而是包含输出、消息和警告：
    
    ```{r}
    x <- list(1, -1)
    x %>% map(quietly(log)) %>% str()
    ```

## Mapping over multiple arguments | 多参数映射

So far we've mapped along a single input. But often you have multiple related inputs that you need iterate along in parallel. That's the job of the `map2()` and `pmap()` functions. For example, imagine you want to simulate some random normals with different means. You know how to do that with `map()`:

迄今为止，我们的映射函数都是对单个输入进行映射。但我们经常会有多个相关的输入需要同步迭代，这就是 map2() 和 pmap() 函数的用武之地。例如，假设你想模拟几个均值不同的随机正态分布，我们已经知道了如何使用 map() 函数来完成这个任务：

```{r}
mu <- list(5, 10, -3)
mu %>% 
  map(rnorm, n = 5) %>% 
  str()
```

What if you also want to vary the standard deviation? One way to do that would be to iterate over the indices and index into vectors of means and sds:

如果还想让标准差也不同，那么该怎么办呢？其中一种方法是使用均值向量和标准差向量的索引进行迭代：

```{r}
sigma <- list(1, 5, 10)
seq_along(mu) %>% 
  map(~rnorm(5, mu[[.]], sigma[[.]])) %>% 
  str()
```

But that obfuscates the intent of the code. Instead we could use `map2()` which iterates over two vectors in parallel:

但是这种方法很难让人理解代码的本意。相反，我们应该使用 map2() 函数，它可以对两个向量进行同步迭代：

```{r}
map2(mu, sigma, rnorm, n = 5) %>% str()
```

`map2()` generates this series of function calls:

map2() 函数可以生成以下一系列函数调用：

```{r, echo = FALSE}
knitr::include_graphics("diagrams/lists-map2.png")
```

Note that the arguments that vary for each call come _before_ the function; arguments that are the same for every call come _after_.

注意，每次调用时值发生变化的参数（这里是 mu 和 sigma）要放在映射函数（这里是rnorm）的前面，值保持不变的参数（这里是 n）要放在映射函数的后面。

Like `map()`, `map2()` is just a wrapper around a for loop:

和 map() 函数一样，map2() 函数也是对 for 循环的包装：

```{r}
map2 <- function(x, y, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], y[[i]], ...)
  }
  out
}
```

You could also imagine `map3()`, `map4()`, `map5()`, `map6()` etc, but that would get tedious quickly. Instead, purrr provides `pmap()` which takes a list of arguments. You might use that if you wanted to vary the mean, standard deviation, and number of samples:

还可以开发 ma3()、map4()、map5()、map6() 等，但这样你很快就会感到无聊。相反，purrr 提供了 pmap() 函数，它可以将一个列表作为参数。如果你想生成均值、标准差和样本数量都不相同的正态分布，那么就可以使用这个函数：

```{r}
n <- list(1, 3, 5)
args1 <- list(n, mu, sigma)
args1 %>%
  pmap(rnorm) %>% 
  str()
```

That looks like:
图形表示如下所示：

```{r, echo = FALSE}
knitr::include_graphics("diagrams/lists-pmap-unnamed.png")
```

If you don't name the list's elements, `pmap()` will use positional matching when calling the function. That's a little fragile, and makes the code harder to read, so it's better to name the arguments:

如果没有为列表的元素命名，那么 pmap() 在调用函数时就会按照位置匹配。这样做比较容易出错，而且会让代码的可读性变差，因此最好使用命名参数：

```{r, eval = FALSE}
args2 <- list(mean = mu, sd = sigma, n = n)
args2 %>% 
  pmap(rnorm) %>% 
  str()
```

That generates longer, but safer, calls:
这样生成的函数调用更长一些，但更安全：

```{r, echo = FALSE}
knitr::include_graphics("diagrams/lists-pmap-named.png")
```

Since the arguments are all the same length, it makes sense to store them in a data frame:

因为长度都是相同的，所以可以将各个参数保存在一个数据框中：

```{r}
params <- tribble(
  ~mean, ~sd, ~n,
    5,     1,  1,
   10,     5,  3,
   -3,    10,  5
)
params %>% 
  pmap(rnorm)
```

As soon as your code gets complicated, I think a data frame is a good approach because it ensures that each column has a name and is the same length as all the other columns.

当代码变得比较复杂时，我们认为使用数据框是一种非常好的方法，因为这样可以确保每列都具有名称，而且与其他列具有相同的长度。

### Invoking different functions | 调用不同函数 

There's one more step up in complexity - as well as varying the arguments to the function you might also vary the function itself:

还有一种更复杂的情况：不但传给函数的参数不同，甚至函数本身也是不同的。

```{r}
f <- c("runif", "rnorm", "rpois")
param <- list(
  list(min = -1, max = 1), 
  list(sd = 5), 
  list(lambda = 10)
)
```

To handle this case, you can use `invoke_map()`:

为了处理这种情况，你可以使用 invoke_map() 函数：

```{r}
invoke_map(f, param, n = 5) %>% str()
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/lists-invoke.png")
```

The first argument is a list of functions or character vector of function names. The second argument is a list of lists giving the arguments that vary for each function. The subsequent arguments are passed on to every function.

第一个参数是一个函数列表或包含函数名称的字符向量。第二个参数是列表的一个列表， 其中给出了要传给各个函数的不同参数。随后的参数要传给每个函数。

And again, you can use `tribble()` to make creating these matching pairs a little easier:

同样地，我们可以通过 tribble() 函数使得这些参数配对更加容易：

```{r, eval = FALSE}
sim <- tribble(
  ~f,      ~params,
  "runif", list(min = -1, max = 1),
  "rnorm", list(sd = 5),
  "rpois", list(lambda = 10)
)
sim %>% 
  mutate(sim = invoke_map(f, params, n = 10))
```

## Walk | 游走函数 {#walk}

Walk is an alternative to map that you use when you want to call a function for its side effects, rather than for its return value. You typically do this because you want to render output to the screen or save files to disk - the important thing is the action, not the return value. Here's a very simple example:

如果调用函数的目的是利用其副作用，而不是返回值时，那么就应该使用游走函数，而不是映射函数。通常来说，使用这个函数的目的是在屏幕上提供输出或者将文件保存到磁盘——重要的是操作过程，而不是返回值。以下是一个非常简单的示例：

```{r}
x <- list(1, "a", 3)

x %>% 
  walk(print)
```

`walk()` is generally not that useful compared to `walk2()` or `pwalk()`. For example, if you had a list of plots and a vector of file names, you could use `pwalk()` to save each file to the corresponding location on disk:

一般来说，walk() 函数不如 walk2() 和 pwalk() 实用。例如，如果有一个图形列表和一个文件名向量，那么你就可以使用 pwalk() 将每个文件保存到相应的磁盘位置：

```{r, eval = FALSE}
library(ggplot2)
plots <- mtcars %>% 
  split(.$cyl) %>% 
  map(~ggplot(., aes(mpg, wt)) + geom_point())
paths <- stringr::str_c(names(plots), ".pdf")

pwalk(list(paths, plots), ggsave, path = tempdir())
```

`walk()`, `walk2()` and `pwalk()` all invisibly return `.x`, the first argument. This makes them suitable for use in the middle of pipelines. 

walk()、walk2() 和 pwalk() 都会隐式地返回 .x，即第一个参数。这使得它们非常适用于管道操作。

## Other patterns of for loops | for循环的其他模式

Purrr provides a number of other functions that abstract over other types of for loops. You'll use them less frequently than the map functions, but they're useful to know about. The goal here is to briefly illustrate each function, so hopefully it will come to mind if you see a similar problem in the future. Then you can go look up the documentation for more details.

purrr 还提供了其他一些函数，可以对 for 循环的其他模式进行抽象。虽然它们的使用频率比映射函数低，但了解一下还是有用的。本节的目的就是对这些函数进行简单介绍，以便你将来遇到类似问题时能够想起它们，再查阅文档以获得更多详细信息。

### Predicate functions | 预测函数

A number of functions work with __predicate__ functions that return either a single `TRUE` or `FALSE`.

一些函数可以与返回 TRUE 或 FALSE 的预测函数一同使用。

`keep()` and `discard()` keep elements of the input where the predicate is `TRUE` or `FALSE` respectively:

keep() 和 discard() 函数可以分别保留输入中预测值为 TRUE 和 FALSE 的元素：

```{r}
iris %>% 
  keep(is.factor) %>% 
  str()

iris %>% 
  discard(is.factor) %>% 
  str()
```

`some()` and `every()` determine if the predicate is true for any or for all of
the elements.

some() 和 every() 函数分别用来确定预测值是否对某个元素为真以及是否对所有元素为真：

```{r}
x <- list(1:5, letters, list(10))

x %>% 
  some(is_character)

x %>% 
  every(is_vector)
```

`detect()` finds the first element where the predicate is true; `detect_index()` returns its position.

detect() 函数可以找出预测值为真的第一个元素，detect_index() 函数则可以返回这个元素的位置：

```{r}
x <- sample(10)
x

x %>% 
  detect(~ . > 5)

x %>% 
  detect_index(~ . > 5)
```

`head_while()` and `tail_while()` take elements from the start or end of a vector while a predicate is true:

head_while() 和 tail_while() 分别从向量的开头和结尾找出预测值为真的元素：

```{r}
x %>% 
  head_while(~ . > 5)

x %>% 
  tail_while(~ . > 5)
```

### Reduce and accumulate | 归约与累计

Sometimes you have a complex list that you want to reduce to a simple list by repeatedly applying a function that reduces a pair to a singleton. This is useful if you want to apply a two-table dplyr verb to multiple tables. For example, you might have a list of data frames, and you want to reduce to a single data frame by joining the elements together:

对于一个复杂的列表，有时你想将其归约为一个简单列表，方式是使用一个函数不断将两个元素合成一个。如果想要将两表间的一个 dplyr 操作应用于多张表，那么这种方法是非常适合的。例如，如果你有一个数据框列表，并想要通过不断将两个数据框连接成一个的方式来最终生成一个数据框：

```{r}
dfs <- list(
  age = tibble(name = "John", age = 30),
  sex = tibble(name = c("John", "Mary"), sex = c("M", "F")),
  trt = tibble(name = "Mary", treatment = "A")
)

dfs %>% reduce(full_join)
```

Or maybe you have a list of vectors, and want to find the intersection:

或者你想要找出一张向量列表中的向量间的交集：

```{r}
vs <- list(
  c(1, 3, 5, 6, 10),
  c(1, 2, 3, 7, 8, 10),
  c(1, 2, 3, 4, 8, 9, 10)
)

vs %>% reduce(intersect)
```

`reduce()` takes a "binary" function (i.e. a function with two primary inputs), and applies it repeatedly to a list until there is only a single element left.

reduce() 函数使用一个“二元”函数（即具有两个基本输入的函数），将其不断应用于一个列表，直到最后只剩下一个元素为止。

`accumulate()` is similar but it keeps all the interim results. You could use it to implement a cumulative sum:

累计函数与归约函数很相似，但前者会保留所有中间结果。你可以使用它来实现累计求和：

```{r}
x <- sample(10)
x
x %>% accumulate(`+`)
```

### Exercises | 练习

1.  Implement your own version of `every()` using a for loop. Compare it with
    `purrr::every()`. What does purrr's version do that your version doesn't?
    
    使用 for 循环实现一个自定义的 every() 函数，并将其与 purrr::every() 比较一下。
    purrr 版的函数具有哪些自定义函数中没有的功能？

1.  Create an enhanced `col_summary()` that applies a summary function to every
    numeric column in a data frame.
    
    创建一个加强版的 col_sum() 函数，将摘要函数应用于数据框的每个数值列。

1.  A possible base R equivalent of `col_summary()` is:

R 基础包中可能与 col_sum() 等价的一个函数是：

    ```{r}
    col_sum3 <- function(df, f) {
      is_num <- sapply(df, is.numeric)
      df_num <- df[, is_num]

      sapply(df_num, f)
    }
    ```
    
    But it has a number of bugs as illustrated with the following inputs:
    
    但这个函数在使用以下输入时出现了几个 bug：
    
    ```{r, eval = FALSE}
    df <- tibble(
      x = 1:3, 
      y = 3:1,
      z = c("a", "b", "c")
    )
    # OK
    # 没问题
    col_sum3(df, mean)
    # Has problems: don't always return numeric vector
    # 有问题：不要总是返回数字向量
    col_sum3(df[1:2], mean)
    col_sum3(df[1], mean)
    col_sum3(df[0], mean)
    ```
    
    What causes the bugs?
    引发 bug 的原因是什么呢？
